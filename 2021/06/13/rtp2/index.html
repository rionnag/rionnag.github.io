<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>rtp学习笔记（二） RTP数据传输协议 | Rionnag&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="（来自《RTP：Audio and video for the Internet》第四章） RTP数据传输协议包含：1.RTP会话、2.RTP数据传输包、3.包验证、4.Translators and Mixers 一、RTP Sessions（RTP会话）会话由使用 RTP 进行通信的一组参与者组成。一个参与者可能在多个 RTP 会话中处于活动状态——例如，一个会话用于交换音频数据，另一个会话用">
<meta property="og:type" content="article">
<meta property="og:title" content="rtp学习笔记（二） RTP数据传输协议">
<meta property="og:url" content="http://example.com/2021/06/13/rtp2/index.html">
<meta property="og:site_name" content="Rionnag&#39;s blog">
<meta property="og:description" content="（来自《RTP：Audio and video for the Internet》第四章） RTP数据传输协议包含：1.RTP会话、2.RTP数据传输包、3.包验证、4.Translators and Mixers 一、RTP Sessions（RTP会话）会话由使用 RTP 进行通信的一组参与者组成。一个参与者可能在多个 RTP 会话中处于活动状态——例如，一个会话用于交换音频数据，另一个会话用">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-06-13T09:38:38.000Z">
<meta property="article:modified_time" content="2021-06-14T07:29:32.438Z">
<meta property="article:author" content="rionnag">
<meta property="article:tag" content="rtp">
<meta property="article:tag" content="音视频">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Rionnag's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Rionnag&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-rtp2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/13/rtp2/" class="article-date">
  <time class="dt-published" datetime="2021-06-13T09:38:38.000Z" itemprop="datePublished">2021-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      rtp学习笔记（二） RTP数据传输协议
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>（来自《RTP：Audio and video for the Internet》第四章）</p>
<p>RTP数据传输协议包含：1.RTP会话、2.RTP数据传输包、3.包验证、4.Translators and Mixers</p>
<h1 id="一、RTP-Sessions（RTP会话）"><a href="#一、RTP-Sessions（RTP会话）" class="headerlink" title="一、RTP Sessions（RTP会话）"></a>一、RTP Sessions（RTP会话）</h1><p>会话由使用 RTP 进行通信的一组参与者组成。一个参与者可能在多个 RTP 会话中处于活动状态——例如，一个会话用于交换音频数据，另一个会话用于交换视频数据。对于每个参与者，会话由数据应发送到的网络地址和端口对以及接收数据的端口对标识。发送端口和接收端口可能相同。每个端口对包括两个相邻的端口：一个用于 RTP 数据包的偶数端口，以及用于 RTCP 控制包的下一个更高（奇数）端口。 UDP/IP 的默认端口对是 5004 和 5005，但许多应用程序在会话设置期间动态分配端口并忽略默认值。 RTP 会话旨在传输单一类型的媒体；在多媒体通信中，每种媒体类型都应承载在单独的 RTP 会话中。</p>
<p>（RTP 规范的最新版本放宽了 RTP 数据端口为偶数的要求，并允许不相邻的 RTP 和 RTCP 端口。此更改使在存在某些类型的网络地址转换 (NAT) 设备的环境中使用 RTP 成为可能。如果可能，为了与旧实现兼容，使用相邻端口是明智的，即使这不是严格要求的。）</p>
<p>会话可以是单播的，可以是直接在两个参与者之间（点对点会话）或重新分配数据的中央服务器。或者它可以多播给一组参与者。会话也不必限于单个传输地址空间。例如，RTP 转换器可用于桥接单播和多播之间或 IP 和其他传输（如 IPv6 或 ATM）之间的会话。本章稍后将在标题为 Translators 和 Mixers 的部分中更详细地讨论转换器。</p>
<p>可能的会话范围意味着 RTP 端系统应该被编写成对底层传输基本上是不可知的。将传输地址和端口的知识仅限于您的低级网络代码，并使用 RTP 级机制进行参与者识别是一个很好的设计。 RTP 为此目的提供了一个“synchronization source”。</p>
<hr>
<p><em>注意：</em></p>
<p><em>1.您不应使用传输地址作为参与者标识符，因为数据可能已通过可能隐藏原始源地址的转换器或混合器。而是使用同步源标识符。</em></p>
<p><em>2.您不应假设一个会话只有两个参与者，即使它使用的是单播。单播连接的另一端可能是一个 RTP 转换器或混合器，充当潜在无限数量的其他参与者的网关。</em></p>
<hr>
<p>一个好的设计使参与者几乎看不到实际的交流方式。</p>
<h1 id="二、RTP-Data-Transfer-Packet（RTP数据传输包）"><a href="#二、RTP-Data-Transfer-Packet（RTP数据传输包）" class="headerlink" title="二、RTP Data Transfer Packet（RTP数据传输包）"></a>二、RTP Data Transfer Packet（RTP数据传输包）</h1><p>RTP数据包分为四个部分：</p>
<p>1.强制的RTP数据头</p>
<p>2.可选的数据头扩展</p>
<p>3.可选的负载头（取决于所使用的负载格式）</p>
<p>4.负载数据本身</p>
<p>整个 RTP 数据包包含在较低层的有效载荷中，通常是 UDP/IP。</p>
<pre><code>------------------------------------------
|v |P|X|CC  |M|PT     |Sequence number   |
|----------------------------------------|
|                Timestamp               |
|----------------------------------------|
|Synchronization source (SSRC) identifier|
|----------------------------------------|
|Contributing sources(CSRC) identifiers  |
|----------------------------------------| 
|          Header extension (optional)   |
|----------------------------------------|
|Payload header(payload format dependent)|
|----------------------------------------|
|                                        |
|              Payload data              |
|                           -------------|
|                           |  Padding   |
------------------------------------------</code></pre>
<h2 id="2-1-Header-Elements（头元素）"><a href="#2-1-Header-Elements（头元素）" class="headerlink" title="2.1 Header Elements（头元素）"></a>2.1 Header Elements（头元素）</h2><p>强制性的 RTP 数据包头的长度通常为 12 个八位字节，尽管它可能包含一个贡献源列表，它可以将长度扩展 4 到 60 个额外的八位字节。强制报头中的字段是有效载荷类型、序列号、时间戳和同步源标识符。此外，还有贡献源的计数、感兴趣事件的标记、对填充和标头扩展的支持以及版本号。</p>
<h3 id="2-1-1-PAYLOAD-TYPE（负载类型）"><a href="#2-1-1-PAYLOAD-TYPE（负载类型）" class="headerlink" title="2.1.1 PAYLOAD TYPE（负载类型）"></a>2.1.1 PAYLOAD TYPE（负载类型）</h3><p>RTP 报头的 payload type 或 PT 字段标识了由 RTP 数据包传输的媒体。接收应用程序检查负载类型以确定如何处理数据——例如，将其传递给特定的解压缩器。有效载荷字段的确切解释由 RTP 配置文件定义，它将有效载荷类型编号绑定到有效载荷格式规范，或由非 RTP 方式定义。</p>
<p>许多应用程序在 RTP 配置文件下运行，用于具有最小控制的音频和视频会议 (RFC 1890)。此配置文件（通常称为 audio/video配置文件）定义了负载类型编号和负载格式规范之间的默认映射表。 Table 4.1 中显示了这些静态分配的示例（这不是完整列表；配置文件定义了其他分配）。除了静态分配之外，带外信令（例如，使用 SIP、RTSP、SAP 或 H.323）可用于定义映射。当使用音频/视频配置文件时，96 到 127 范围内的有效负载类型以这种方式保留用于动态分配；其他配置文件可能会指定不同的范围。</p>
<p>负载格式根据 MIME 命名空间命名。这个命名空间最初是为电子邮件定义的，用于识别附件的内容，但它已经成为媒体格式的通用命名空间，并在许多应用程序中使用。将 MIME 类型与 RTP 一起使用是相对较新的——有效载荷类型名称最初占据一个单独的命名空间——但它是一个强大的功能，为每种类型的媒体提供传输和编码选项的中央存储库。</p>
<p>所有负载格式现在都应该有一个 MIME 类型注册。较新的有效载荷格式将其包含在其规范中。</p>
<p>无论负载类型分配是静态的还是动态的，都需要向应用程序描述会话，以便应用程序知道要使用哪些负载类型。描述会话的常用方法是会话描述协议 (SDP)。一个会话描述可能如下所示：</p>
<pre><code>v=0
o=bloggs 2890844526 2890842807 IN IP4 10.45.1.82 
s=-
e=j.bloggs@example.com(Joe Bloggs)
c=IN IP4 224.2.17.12/127
t=2873397496 2873404696 
m=audio 49170 RTP/AVP 0
m=video 51372 RTP/AVP 98
a=rtpmap:98 H263-1998/90000 </code></pre>
<p>我们对 RTP 的讨论感兴趣的是 c= 和 m= 行，它们为 RTP 会话通信地址和端口并定义使用的配置文件和有效载荷类型，以及 a=rtpmap: 行，它生成动态有效载荷类型分配。</p>
<p>该示例描述了两个 RTP 会话：音频被发送到端口 49170 上的 IPv4 多播组 224.2.17.12，生存时间为 127，视频被发送到端口 51372 上的同一个多播组。音频和视频都使用 RTP /AVP 作为他们的交通工具；这是使用 RTP 配置文件进行音频和视频会议的最小控制 RTP 传输。</p>
<p>用于音频的有效载荷类型为 0。这是配置文件中的静态分配，即 AUDIO/PCMU 的有效载荷格式。视频的载荷类型为 98，由 a=rtpmap: 行映射到 VIDEO/H263-1998 的载荷格式。通过参考 MIME 类型分配表，我们发现 VIDEO/H263-1998 的定义在 RFC 2429 中。</p>
<p>尽管 SDP 是描述 RTP 会话的常用解决方案，但 RTP 中没有任何内容需要使用 SDP。例如，基于 ITU 建议的 H.323 的应用程序使用 RTP 进行媒体传输，但使用不同的机制 (H.245) 来描述会话。RTP 媒体时钟，以及任何有效载荷标头的格式和有效载荷本身。</p>
<hr>
<p><em>关于载荷类型编号到净荷格式的静态分配与动态分配的优点存在一些争论，这可能受到音频/视频配置文件中一长串静态分配和动态分配所需信令的感知复杂性的鼓励。</em></p>
<p><em>当 RTP 是新的并且它的使用是简单有效载荷格式的实验主题时，静态有效载荷类型分配是有意义的。接收器可以仅根据有效载荷类型编号对 RTP 有效载荷进行解码，因为编解码器不需要额外的配置，并且没有信令简化了这些新应用程序的开发。</em></p>
<p><em>然而，随着设计人员获得 RTP 的经验并将其应用于更复杂的有效载荷格式，很明显进行静态分配的做法是有缺陷的。</em></p>
<p><em>今天使用的大多数有效载荷格式除了有效载荷类型分配之外还需要一些配置，需要使用信令；和新兴应用程序（例如 IP 语音和视频点播）需要用于用户位置、身份验证和支付的信令。因为无论如何都需要信令，静态有效载荷类型分配的动机就失去了。</em></p>
<p><em>要求动态分配还避免了由于有效载荷类型空间耗尽而导致的问题；只有 127 种可能的静态分配，并且可能的有效载荷格式的数量远远超过这些。动态分配只允许将会话期间所需的那些格式绑定到有效负载类型编号。</em></p>
<p><em>因此，IETF 音频/视频传输工作组的政策是不再进行静态分配，并且应用程序应在带外发出其有效载荷类型使用情况的信号。</em></p>
<hr>
<p>对于静态分配，时钟速率在配置文件中指定；动态分配必须指示时钟速率同负载类型和负载格式之间的映射。例如，在前面的会话描述中，a=rtpmap: 行为 VIDEO/H263-1998 有效载荷格式指定了 90,000-Hz 时钟。大多数有效载荷格式以一组有限的时钟速率运行，有效载荷格式规范定义了哪些速率是有效的。</p>
<p>RTP 会话不需要只使用单一的有效载荷格式；会话中可以使用多种有效载荷格式，不同的格式由不同的有效载荷类型标识。格式可以在会话内随时改变，只要预先传达了有效载荷类型到有效载荷格式的映射，在改变发生之前不需要信令。一个例子可能是在 IP 语音会话中对 DTMF 音进行编码，以支持“按 0 与操作员通话”风格的自动化服务，其中一种格式用于语音，另一种格式用于音调。</p>
<p>尽管可以在一个会话中使用多种有效载荷格式，但有效载荷类型并不打算用于多路复用不同类别的媒体。例如，如果应用程序同时发送音频和视频，则它们应该作为两个不同的 RTP 会话在不同的地址/端口上发送，而不是作为单个 RTP 会话发送并按有效载荷类型进行多路分解。这种媒体分离允许应用程序为不同的媒体请求不同的网络服务质量，这也是 RTP 控制协议正确运行所必需的。</p>
<h3 id="2-1-2-SEQUENCE-NUMBER（序列号）"><a href="#2-1-2-SEQUENCE-NUMBER（序列号）" class="headerlink" title="2.1.2 SEQUENCE NUMBER（序列号）"></a>2.1.2 SEQUENCE NUMBER（序列号）</h3><p>RTP的 sequence number 用于识别数据包，并在数据包丢失或无序传送时向接收器提供指示。它不用于安排数据包的播放——这是时间戳的目的——尽管它确实允许接收器重建数据包的发送顺序。</p>
<p>序列号是一个无符号的 16 位整数，它随着每个数据包的发送而增加 1，并在达到最大值时回零。 16 位空间的一个重要结果是序列号溢出发生得相对频繁：典型的 IP 语音应用程序以 20 毫秒的数据包发送音频，大约每 20 分钟溢出一次序列号。</p>
<p>这意味着应用程序不应依赖序列号作为唯一的数据包标识符。相反，建议他们使用 32 位或更宽的扩展序列号来内部识别数据包，低 16 位是来自 RTP 数据包的序列号，高 16 位是序列号的溢出次数：</p>
<pre><code>extended_seq_num = seq_num + (65536 * wrap_around_count) </code></pre>
<p>由于可能的数据包丢失或重新排序，维护溢出计数 (wrap-around-count) 不是在序列号溢出为零时增加计数器的简单问题。 RTP 规范有一个维护溢出计数的算法：</p>
<pre><code>uint16_t    udelta = seq – max_seq 
if (udelta &lt; max_dropout) &#123;     
    if (seq &lt; max_seq) &#123;         
        wrap_around_count++ 
    &#125;     
    max_seq = seq; 
&#125;
else if (udelta &lt;= 65535 – max_misorder) &#123;
    // The sequence number made a very large jump     
    if (seq == bad_seq) &#123;
        // Two sequential packets received; assume the         
        // other side has restarted without telling us         
        ...     
    &#125; else &#123;
        bad_seq = seq + 1;
    &#125; 
&#125; 
else &#123;
    // Duplicate or misordered packet     
    ... 
&#125;</code></pre>
<p>请注意，所有计算都是使用模算术和 16 位无符号量完成的。 seq 和 max_seq 都是来自 RTP 数据包的未扩展序列号。 RTP 规范建议 max_misorder = 100 和 max_dropout = 3000</p>
<p>如果在接收到数据包时立即计算扩展序列号并在此后使用，则大多数应用程序可能忽略扩展序列号溢出。隐藏序列号溢出极大地简化了丢失检测和隐藏、数据包重新排序以及统计数据的维护。除非数据包速率非常高，否则 32 位序列号的溢出时间是大多数应用程序可以忽略的。例如，前面给出的 IP 语音示例将需要两年多的时间来溢出扩展序列号。</p>
<p>如果数据包速率非常高，则在应用程序运行时可能会出现 32 位扩展序列号溢出。在为此类环境设计应用程序时，必须使用更大的扩展序列号（例如 64 位）来避免该问题，或者通过使用 32 位模运算处理序列号溢出来构建应用程序.序列号溢出期间的不正确操作是一个常见问题，尤其是当数据包在溢出期间丢失或重新排序的时候。</p>
<p>序列号的初始值应该随机选择，而不是从零开始。此预防措施旨在使对加密 RTP 流的已知纯文本攻击更加困难。即使源不加密，使用随机初始序列号也很重要，因为流可能会通过源不知道的加密转换器，并且在转换器中添加随机偏移并非易事（因为序列号是在 RTCP 接收报告包中报告；参见 RTP 控制协议）。一个常见的实现问题是假设序列号从零开始；无论初始序列号如何，接收器都应该能够播放流（处理延迟连接也需要此功能）。</p>
<p>序列号应该始终遵循一个连续的序列，每发送一个数据包就增加一个，并且永远不会向前或向后跳跃（当然，环绕除外）。无论媒体如何生成，此要求都应适用于有效载荷格式的更改。例如，当您将视频剪辑拼接在一起时（可能是插入广告），RTP 序列号空间必须是连续的，并且不得在每个剪辑的开头重置。这对流媒体服务器的设计有影响，因为它们不能依赖与媒体文件一起存储的序列号，并且必须即时生成序列号。</p>
<p>序列号的主要用途是丢失检测。序列号空间中​​的间隙向接收器表明它必须采取行动来恢复或隐藏丢失的数据。这在 Error Concealment 和Error Correction 中有更详细的讨论。</p>
<p>序列号的第二个用途是允许重建数据包发送的顺序。接收器不一定关心这一点——因为许多有效载荷格式允许以任何顺序对数据包进行解码——但是在接收到数据包时将数据包按顺序排序可能会使丢失检测更容易。播出缓冲算法的设计在 Chapter 6 媒体捕捉、播出和计时中有更详细的讨论。</p>
<h3 id="2-1-3-TIMESTAMP（时间戳）"><a href="#2-1-3-TIMESTAMP（时间戳）" class="headerlink" title="2.1.3 TIMESTAMP（时间戳）"></a>2.1.3 TIMESTAMP（时间戳）</h3><p>RTP timestamp 表示数据包中媒体数据的第一个八位字节的采样时刻，用于调度媒体数据的播放。时间戳是一个 32 位无符号整数，它以与媒体相关的速率增加，并在超过最大值时环绕到零。对于典型的视频编解码器，使用 90kHz 的时钟频率，对应大约 13 小时的环绕；对于 8kHz 音频，间隔大约为 6 天。</p>
<p>时间戳的初始值是随机选择的，而不是从零开始。与序列号一样，此预防措施旨在使对加密 RTP 流的已知纯文本攻击更加困难。即使源不加密，随机初始时间戳的使用也很重要，因为流可能通过源不知道的加密转换器。一个常见的实现问题是假设时间戳从零开始。无论初始时间戳如何，接收器都应该能够播放流并准备好处理环绕；因为时间戳不是从零开始，所以任何时候都可能发生回绕。</p>
<p>时间戳回绕是 RTP 操作的正常部分，应由所有应用程序处理。使用扩展时间戳，可能是 64 位值，可以使大多数应用程序不知道回绕。但是，不建议使用扩展时间戳，因为 64 位算法在当今的处理器上通常效率低下。</p>
<p>更好的设计使用 32 位模运算执行所有时间戳计算。这种方法允许计算时间戳之间的差异，前提是比较的数据包在彼此的时间戳空间的一半之内。</p>
<p>时间戳源自必须以线性和单调方式增加的媒体时钟（当然，环绕式除外），为每个 RTP 会话生成单个时间线。这与生成媒体流的方式无关。</p>
<p>一个示例有助于阐明时间戳增加方式的含义：在单个 RTP 会话中将音频剪辑拼接在一起时，RTP 时间戳必须形成连续序列，并且不得在每个剪辑的开头重置。这些要求在 图 4.3 中进行了说明，这表明 RTP 接收器无法从 RTP 头中得知发生了变化。</p>
<p>当发生快进或倒带操作时也是如此：时间戳必须形成一个连续的序列，而不是跳来跳去。这一要求在实时流协议 (RTSP) 的设计中很明显，包括“正常播放时间”的概念，表示流中的时间索引。由于必须保持 RTP 时间戳的连续性，因此在查找操作期间，RTSP 服务器必须发送 RTP 时间戳与正常播放时间之间的更新映射。</p>
<p>RTP 时间戳的连续性对流媒体服务器的设计有影响。服务器不能依赖与媒体文件一起存储的时间戳（或序列号），但必须即时生成它们，同时考虑媒体中的查找操作和 RTP 会话中已播放的任何先前数据的持续时间。</p>
<p>对以线性和单调方式增加的媒体时钟的要求并不一定意味着媒体数据的采样顺序就是它的发送顺序。在生成媒体帧之后——因此获得了它们的时间戳——它们可以在分组之前重新排序。结果，即使保持序列号顺序，数据包也可能不按时间戳顺序传输。接收器必须重建时间戳顺序才能播放媒体。</p>
<p>一个例子是 MPEG 视频，它包含关键帧和从它们向前（P 帧）和向后（B 帧）预测的增量编码帧。当使用 B 帧时，它们是从后面的数据包中预测出来的，因此必须延迟并乱序发送。结果是 RTP 流将具有非单调递增的时间戳。 另一个例子是使用交错以减少突发丢失的影响。在所有情况下，接收者必须重建以播放媒体的单个时间线被保留。</p>
<p>RTP 数据包上的时间戳在每个环绕周期内不一定是唯一的。如果两个数据包包含来自同一采样时刻的数据，则它们将具有相同的时间戳。当一个大的视频帧被分成多个 RTP 数据包进行传输（数据包将具有不同的序列号但具有相同的时间戳）时，通常会发生时间戳的重复。</p>
<p>用于生成时间戳的媒体时钟的标称速率由使用的配置文件和/或有效载荷格式定义。对于具有静态有效载荷类型分配的有效载荷格式，当使用静态有效载荷类型时，时钟速率是隐式的（它被指定为有效载荷类型分配的一部分）。动态分配过程必须指定速率和有效载荷类型（参见本章前面标题为 Payload Type 的部分）。所选的速率必须足以以所需的精度执行唇形同步，并测量网络传输时间的变化。时钟频率不可任意选择；大多数有效载荷格式定义了一个或多个可接受的速率。</p>
<p>音频有效负载格式通常使用采样率作为其媒体时钟，因此每次读取完整样本时时钟增加 1。有两个例外： MPEG 音频使用 90kHz 时钟以兼容非 RTP MPEG 传输； G.722 是一种 16kHz 语音编解码器，它使用 8kHz 媒体时钟与 RFC 1890 向后兼容，RFC 1890 错误地指定了 8kHz 而不是 16kHz。</p>
<p>视频有效载荷格式通常使用 90kHz 时钟，以便与 MPEG 兼容，并且因为这样做会为当今广泛使用的典型 24Hz、25Hz、29.97Hz 和 30Hz 帧速率以及 50Hz、59.94Hz 和 60Hz 场速率产生整数时间戳增量.示例包括 PAL（相位交替线）和 NTSC（国家电视标准委员会）电视，以及 HDTV（高清晰度电视）格式。</p>
<p>重要的是要记住，RTP 不保证媒体时钟的分辨率、准确性或稳定性——这些属性被认为是依赖于应用程序的，并且超出了 RTP 的范围——一般来说，已知的只是其标称速率.应用程序应该能够在发送方和接收方处理媒体时钟的可变性，除非它们具有相反的特定知识。</p>
<hr>
<p><em>在某些情况下，可以定义媒体时钟的分辨率、精度和稳定性，并使用这些知识来简化应用程序设计。这通常只有在单个实体同时控制发送方和接收方，或者两者都设计为具有严格时钟规范的配置文件时才有可能</em></p>
<hr>
<h3 id="2-1-4-SSRC-SYNCHRONIZATION-SOURCE-（同步源）"><a href="#2-1-4-SSRC-SYNCHRONIZATION-SOURCE-（同步源）" class="headerlink" title="2.1.4 SSRC(SYNCHRONIZATION SOURCE)（同步源）"></a>2.1.4 SSRC(SYNCHRONIZATION SOURCE)（同步源）</h3><p>synchronization source (SSRC) 标识是 RTP 会话中的参与者。它是一个临时的、每个会话的标识符，通过 RTP 控制协议映射到一个长期存在的规范名称 CNAME。</p>
<p>SSRC 是一个 32 位整数，由参与者在加入会话时随机选择。选择一个 SSRC 标识符后，参与者在它发出的数据包中使用它。由于 SSRC 值是在本地选择的，因此两个参与者可以选择相同的值。当一个应用程序从另一个应用程序接收到包含为其自身选择的 SSRC 标识符的数据包时，可能会检测到此类冲突。</p>
<p>如果一个参与者检测到它正在使用的 SSRC 与另一个参与者选择的 SSRC 之间发生冲突，它必须为原始 SSRC 发送一个 RTCP BYE（参见标题为 RTCP BYE：Membership Control 的部分，在 Chapter 5，RTP 控制协议）并为自身选择另一个 SSRC。这种冲突检测机制确保 SSRC 对于会话中的每个参与者都是唯一的。</p>
<p>重要的是使用高质量的随机源来生成 SSRC，并实现碰撞检测。特别是，随机数生成器的种子不应基于会话加入的时间或会话的传输地址，因为如果多个参与者同时加入，可能会导致冲突。</p>
<p>具有相同 SSRC 的所有数据包构成单个时序和序列号空间的一部分，因此接收器必须按 SSRC 将数据包分组以进行回放。如果参与者在一个 RTP 会话中生成多个流——例如，来自不同的摄像机——每个流都必须被标识为不同的 SSRC，以便接收者可以区分哪些数据包属于每个流。</p>
<h3 id="2-1-5-CSRCs-CONTRIBUTING-SOURCE-（贡献源）"><a href="#2-1-5-CSRCs-CONTRIBUTING-SOURCE-（贡献源）" class="headerlink" title="2.1.5 CSRCs(CONTRIBUTING SOURCE)（贡献源）"></a>2.1.5 CSRCs(CONTRIBUTING SOURCE)（贡献源）</h3><p>在正常情况下，RTP 数据由单个源生成，但是当多个 RTP 流通过混合器或转换器时，多个数据源可能对一个 RTP 数据包做出了贡献。 contributing sources (CSRC) 的列表标识了对 RTP 数据包做出贡献但不负责其计时和同步的参与者。每个贡献源标识符是一个 32 位整数，对应于为此数据包做出贡献的参与者的 SSRC。 CSRC 列表的长度由 RTP 头中的 CC 字段指示。</p>
<p>包含 CSRC 列表的数据包是由 RTP 混合器的操作产生的，如本章后面标题为 mixers 的部分所述。当接收到包含CSRC列表的数据包时，SSRC按照通常的方式将数据包分组进行播出，并将每个CSRC添加到已知参与者列表中。由CSRC识别的每个参与者都会有相应的 RTP 控制协议数据包流，从而更全面地识别参与者。</p>
<h3 id="2-1-6-MARKER"><a href="#2-1-6-MARKER" class="headerlink" title="2.1.6 MARKER"></a>2.1.6 MARKER</h3><p>RTP 报头中的 marker (M) 位用于标记媒体流中感兴趣的事件；它的确切含义由使用的 RTP 配置文件和媒体类型定义。</p>
<p>对于在 RTP 配置文件下运行的音频和视频会议的最小控制的音频流，标记位设置为 1 以指示在一段时间的静音后发送的第一个数据包，否则设置为零。设置为 1 的标记位用作应用程序的提示，这可能是调整其播放点的好时机，因为静默期长度的微小变化通常不会被听众注意到（而播放中的变化正在播放音频时点是可听的）。</p>
<p>对于在 RTP 配置文件下运行的具有最小控制的音频和视频会议的视频流，标记位设置为 1 以指示视频帧的最后一个数据包，否则设置为 0。如果设置为 1，标记将用作应用程序可以开始解码帧的提示，而不是等待下一个数据包（将具有不同的时间戳）来检测应显示该帧。</p>
<p>在所有情况下，标记位仅向应用程序提供提示，即使设置了标记的数据包丢失，应用程序也应设计为操作。对于音频流，由于序列号和时间戳之间的关系发生变化，通常可以凭直觉判断静默期的结束。视频帧的开始可以通过时间戳的变化来检测。如果包含标记位的数据包丢失，应用程序可以使用这些观察来降低性能。</p>
<p>RTP 配置文件可以指定存在额外的标记位，代价是较小的有效载荷类型字段。例如，配置文件可以要求两个标记位和一个六位有效载荷类型。当前没有配置文件使用此功能。</p>
<h3 id="2-1-7-PADDING"><a href="#2-1-7-PADDING" class="headerlink" title="2.1.7 PADDING"></a>2.1.7 PADDING</h3><p>RTP 报头中的 padding (P) 位用于指示负载已被填充超过其自然长度。如果填充被添加到 RTP 数据包，则 P 位被设置，有效载荷的最后一个八位字节填充有填充八位字节数的计数。填充很少使用，但对于某些处理特定块大小的加密方案以及将有效载荷格式调整为固定容量信道，则需要使用填充。</p>
<p>作为使用填充的示例，图 4.4 显示了在 RTP 中打包的 GSM 音频帧，该帧已从 45 个八位字节的自然长度填充为 48 个八位字节（GSM 帧为 33，RTP 报头为 12）。如果使用数据加密标准 (DES)加密数据包，则可能需要此填充，该标准需要 8 个八位字节（64 位）块。</p>
<h3 id="2-1-8-VERSION-NUMBER"><a href="#2-1-8-VERSION-NUMBER" class="headerlink" title="2.1.8 VERSION NUMBER"></a>2.1.8 VERSION NUMBER</h3><p>每个 RTP 数据包包含一个 version number，由 V 字段指示。当前版本的 RTP 定义了附加版本，而以前的 RTP 版本并未广泛使用。版本号字段唯一有意义的用途是作为数据包有效性检查的一部分。</p>
<h2 id="2-2-Header-Extensions"><a href="#2-2-Header-Extensions" class="headerlink" title="2.2 Header Extensions"></a>2.2 Header Extensions</h2><h2 id="2-3-Payload-Headers（负载头）"><a href="#2-3-Payload-Headers（负载头）" class="headerlink" title="2.3 Payload Headers（负载头）"></a>2.3 Payload Headers（负载头）</h2><h2 id="2-4-Payload-Data（负载数据）"><a href="#2-4-Payload-Data（负载数据）" class="headerlink" title="2.4 Payload Data（负载数据）"></a>2.4 Payload Data（负载数据）</h2><h1 id="三、Packet-Validation（包验证）"><a href="#三、Packet-Validation（包验证）" class="headerlink" title="三、Packet Validation（包验证）"></a>三、Packet Validation（包验证）</h1><h1 id="四、Translators-and-Mixers"><a href="#四、Translators-and-Mixers" class="headerlink" title="四、Translators and Mixers"></a>四、Translators and Mixers</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/13/rtp2/" data-id="ckpwaqbsr000530u64bq3euky" data-title="rtp学习笔记（二） RTP数据传输协议" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rtp/" rel="tag">rtp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" rel="tag">音视频</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/06/12/rtp1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">rtp学习笔记（一） RTP传输协议介绍</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/rtp/" rel="tag">rtp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" rel="tag">音视频</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/rtp/" style="font-size: 10px;">rtp</a> <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" style="font-size: 10px;">音视频</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/13/rtp2/">rtp学习笔记（二） RTP数据传输协议</a>
          </li>
        
          <li>
            <a href="/2021/06/12/rtp1/">rtp学习笔记（一） RTP传输协议介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 rionnag<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>