<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Rionnag&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Rionnag&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Rionnag&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rionnag">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Rionnag's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Rionnag&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-rtp2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/13/rtp2/" class="article-date">
  <time class="dt-published" datetime="2021-06-13T09:38:38.000Z" itemprop="datePublished">2021-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/13/rtp2/">rtp学习笔记（二） RTP数据传输协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>（来自《RTP：Audio and video for the Internet》第四章）</p>
<p>RTP数据传输协议包含：1.RTP会话、2.RTP数据传输包、3.包验证、4.Translators and Mixers</p>
<h1 id="一、RTP-Sessions（RTP会话）"><a href="#一、RTP-Sessions（RTP会话）" class="headerlink" title="一、RTP Sessions（RTP会话）"></a>一、RTP Sessions（RTP会话）</h1><p>会话由使用 RTP 进行通信的一组参与者组成。一个参与者可能在多个 RTP 会话中处于活动状态——例如，一个会话用于交换音频数据，另一个会话用于交换视频数据。对于每个参与者，会话由数据应发送到的网络地址和端口对以及接收数据的端口对标识。发送端口和接收端口可能相同。每个端口对包括两个相邻的端口：一个用于 RTP 数据包的偶数端口，以及用于 RTCP 控制包的下一个更高（奇数）端口。 UDP/IP 的默认端口对是 5004 和 5005，但许多应用程序在会话设置期间动态分配端口并忽略默认值。 RTP 会话旨在传输单一类型的媒体；在多媒体通信中，每种媒体类型都应承载在单独的 RTP 会话中。</p>
<p>（RTP 规范的最新版本放宽了 RTP 数据端口为偶数的要求，并允许不相邻的 RTP 和 RTCP 端口。此更改使在存在某些类型的网络地址转换 (NAT) 设备的环境中使用 RTP 成为可能。如果可能，为了与旧实现兼容，使用相邻端口是明智的，即使这不是严格要求的。）</p>
<p>会话可以是单播的，可以是直接在两个参与者之间（点对点会话）或重新分配数据的中央服务器。或者它可以多播给一组参与者。会话也不必限于单个传输地址空间。例如，RTP 转换器可用于桥接单播和多播之间或 IP 和其他传输（如 IPv6 或 ATM）之间的会话。本章稍后将在标题为 Translators 和 Mixers 的部分中更详细地讨论转换器。</p>
<p>可能的会话范围意味着 RTP 端系统应该被编写成对底层传输基本上是不可知的。将传输地址和端口的知识仅限于您的低级网络代码，并使用 RTP 级机制进行参与者识别是一个很好的设计。 RTP 为此目的提供了一个“synchronization source”。</p>
<hr>
<p><em>注意：</em></p>
<p><em>1.您不应使用传输地址作为参与者标识符，因为数据可能已通过可能隐藏原始源地址的转换器或混合器。而是使用同步源标识符。</em></p>
<p><em>2.您不应假设一个会话只有两个参与者，即使它使用的是单播。单播连接的另一端可能是一个 RTP 转换器或混合器，充当潜在无限数量的其他参与者的网关。</em></p>
<hr>
<p>一个好的设计使参与者几乎看不到实际的交流方式。</p>
<h1 id="二、RTP-Data-Transfer-Packet（RTP数据传输包）"><a href="#二、RTP-Data-Transfer-Packet（RTP数据传输包）" class="headerlink" title="二、RTP Data Transfer Packet（RTP数据传输包）"></a>二、RTP Data Transfer Packet（RTP数据传输包）</h1><p>RTP数据包分为四个部分：</p>
<p>1.强制的RTP数据头</p>
<p>2.可选的数据头扩展</p>
<p>3.可选的负载头（取决于所使用的负载格式）</p>
<p>4.负载数据本身</p>
<p>整个 RTP 数据包包含在较低层的有效载荷中，通常是 UDP/IP。</p>
<pre><code>------------------------------------------
|v |P|X|CC  |M|PT     |Sequence number   |
|----------------------------------------|
|                Timestamp               |
|----------------------------------------|
|Synchronization source (SSRC) identifier|
|----------------------------------------|
|Contributing sources(CSRC) identifiers  |
|----------------------------------------| 
|          Header extension (optional)   |
|----------------------------------------|
|Payload header(payload format dependent)|
|----------------------------------------|
|                                        |
|              Payload data              |
|                           -------------|
|                           |  Padding   |
------------------------------------------</code></pre>
<h2 id="2-1-Header-Elements（头元素）"><a href="#2-1-Header-Elements（头元素）" class="headerlink" title="2.1 Header Elements（头元素）"></a>2.1 Header Elements（头元素）</h2><p>强制性的 RTP 数据包头的长度通常为 12 个八位字节，尽管它可能包含一个贡献源列表，它可以将长度扩展 4 到 60 个额外的八位字节。强制报头中的字段是有效载荷类型、序列号、时间戳和同步源标识符。此外，还有贡献源的计数、感兴趣事件的标记、对填充和标头扩展的支持以及版本号。</p>
<h3 id="2-1-1-PAYLOAD-TYPE（负载类型）"><a href="#2-1-1-PAYLOAD-TYPE（负载类型）" class="headerlink" title="2.1.1 PAYLOAD TYPE（负载类型）"></a>2.1.1 PAYLOAD TYPE（负载类型）</h3><p>RTP 报头的 payload type 或 PT 字段标识了由 RTP 数据包传输的媒体。接收应用程序检查负载类型以确定如何处理数据——例如，将其传递给特定的解压缩器。有效载荷字段的确切解释由 RTP 配置文件定义，它将有效载荷类型编号绑定到有效载荷格式规范，或由非 RTP 方式定义。</p>
<p>许多应用程序在 RTP 配置文件下运行，用于具有最小控制的音频和视频会议 (RFC 1890)。此配置文件（通常称为 audio/video配置文件）定义了负载类型编号和负载格式规范之间的默认映射表。 Table 4.1 中显示了这些静态分配的示例（这不是完整列表；配置文件定义了其他分配）。除了静态分配之外，带外信令（例如，使用 SIP、RTSP、SAP 或 H.323）可用于定义映射。当使用音频/视频配置文件时，96 到 127 范围内的有效负载类型以这种方式保留用于动态分配；其他配置文件可能会指定不同的范围。</p>
<p>负载格式根据 MIME 命名空间命名。这个命名空间最初是为电子邮件定义的，用于识别附件的内容，但它已经成为媒体格式的通用命名空间，并在许多应用程序中使用。将 MIME 类型与 RTP 一起使用是相对较新的——有效载荷类型名称最初占据一个单独的命名空间——但它是一个强大的功能，为每种类型的媒体提供传输和编码选项的中央存储库。</p>
<p>所有负载格式现在都应该有一个 MIME 类型注册。较新的有效载荷格式将其包含在其规范中。</p>
<p>无论负载类型分配是静态的还是动态的，都需要向应用程序描述会话，以便应用程序知道要使用哪些负载类型。描述会话的常用方法是会话描述协议 (SDP)。一个会话描述可能如下所示：</p>
<pre><code>v=0
o=bloggs 2890844526 2890842807 IN IP4 10.45.1.82 
s=-
e=j.bloggs@example.com(Joe Bloggs)
c=IN IP4 224.2.17.12/127
t=2873397496 2873404696 
m=audio 49170 RTP/AVP 0
m=video 51372 RTP/AVP 98
a=rtpmap:98 H263-1998/90000 </code></pre>
<p>我们对 RTP 的讨论感兴趣的是 c= 和 m= 行，它们为 RTP 会话通信地址和端口并定义使用的配置文件和有效载荷类型，以及 a=rtpmap: 行，它生成动态有效载荷类型分配。</p>
<p>该示例描述了两个 RTP 会话：音频被发送到端口 49170 上的 IPv4 多播组 224.2.17.12，生存时间为 127，视频被发送到端口 51372 上的同一个多播组。音频和视频都使用 RTP /AVP 作为他们的交通工具；这是使用 RTP 配置文件进行音频和视频会议的最小控制 RTP 传输。</p>
<p>用于音频的有效载荷类型为 0。这是配置文件中的静态分配，即 AUDIO/PCMU 的有效载荷格式。视频的载荷类型为 98，由 a=rtpmap: 行映射到 VIDEO/H263-1998 的载荷格式。通过参考 MIME 类型分配表，我们发现 VIDEO/H263-1998 的定义在 RFC 2429 中。</p>
<p>尽管 SDP 是描述 RTP 会话的常用解决方案，但 RTP 中没有任何内容需要使用 SDP。例如，基于 ITU 建议的 H.323 的应用程序使用 RTP 进行媒体传输，但使用不同的机制 (H.245) 来描述会话。RTP 媒体时钟，以及任何有效载荷标头的格式和有效载荷本身。</p>
<hr>
<p><em>关于载荷类型编号到净荷格式的静态分配与动态分配的优点存在一些争论，这可能受到音频/视频配置文件中一长串静态分配和动态分配所需信令的感知复杂性的鼓励。</em></p>
<p><em>当 RTP 是新的并且它的使用是简单有效载荷格式的实验主题时，静态有效载荷类型分配是有意义的。接收器可以仅根据有效载荷类型编号对 RTP 有效载荷进行解码，因为编解码器不需要额外的配置，并且没有信令简化了这些新应用程序的开发。</em></p>
<p><em>然而，随着设计人员获得 RTP 的经验并将其应用于更复杂的有效载荷格式，很明显进行静态分配的做法是有缺陷的。</em></p>
<p><em>今天使用的大多数有效载荷格式除了有效载荷类型分配之外还需要一些配置，需要使用信令；和新兴应用程序（例如 IP 语音和视频点播）需要用于用户位置、身份验证和支付的信令。因为无论如何都需要信令，静态有效载荷类型分配的动机就失去了。</em></p>
<p><em>要求动态分配还避免了由于有效载荷类型空间耗尽而导致的问题；只有 127 种可能的静态分配，并且可能的有效载荷格式的数量远远超过这些。动态分配只允许将会话期间所需的那些格式绑定到有效负载类型编号。</em></p>
<p><em>因此，IETF 音频/视频传输工作组的政策是不再进行静态分配，并且应用程序应在带外发出其有效载荷类型使用情况的信号。</em></p>
<hr>
<p>对于静态分配，时钟速率在配置文件中指定；动态分配必须指示时钟速率同负载类型和负载格式之间的映射。例如，在前面的会话描述中，a=rtpmap: 行为 VIDEO/H263-1998 有效载荷格式指定了 90,000-Hz 时钟。大多数有效载荷格式以一组有限的时钟速率运行，有效载荷格式规范定义了哪些速率是有效的。</p>
<p>RTP 会话不需要只使用单一的有效载荷格式；会话中可以使用多种有效载荷格式，不同的格式由不同的有效载荷类型标识。格式可以在会话内随时改变，只要预先传达了有效载荷类型到有效载荷格式的映射，在改变发生之前不需要信令。一个例子可能是在 IP 语音会话中对 DTMF 音进行编码，以支持“按 0 与操作员通话”风格的自动化服务，其中一种格式用于语音，另一种格式用于音调。</p>
<p>尽管可以在一个会话中使用多种有效载荷格式，但有效载荷类型并不打算用于多路复用不同类别的媒体。例如，如果应用程序同时发送音频和视频，则它们应该作为两个不同的 RTP 会话在不同的地址/端口上发送，而不是作为单个 RTP 会话发送并按有效载荷类型进行多路分解。这种媒体分离允许应用程序为不同的媒体请求不同的网络服务质量，这也是 RTP 控制协议正确运行所必需的。</p>
<h3 id="2-1-2-SEQUENCE-NUMBER（序列号）"><a href="#2-1-2-SEQUENCE-NUMBER（序列号）" class="headerlink" title="2.1.2 SEQUENCE NUMBER（序列号）"></a>2.1.2 SEQUENCE NUMBER（序列号）</h3><p>RTP的 sequence number 用于识别数据包，并在数据包丢失或无序传送时向接收器提供指示。它不用于安排数据包的播放——这是时间戳的目的——尽管它确实允许接收器重建数据包的发送顺序。</p>
<p>序列号是一个无符号的 16 位整数，它随着每个数据包的发送而增加 1，并在达到最大值时回零。 16 位空间的一个重要结果是序列号溢出发生得相对频繁：典型的 IP 语音应用程序以 20 毫秒的数据包发送音频，大约每 20 分钟溢出一次序列号。</p>
<p>这意味着应用程序不应依赖序列号作为唯一的数据包标识符。相反，建议他们使用 32 位或更宽的扩展序列号来内部识别数据包，低 16 位是来自 RTP 数据包的序列号，高 16 位是序列号的溢出次数：</p>
<pre><code>extended_seq_num = seq_num + (65536 * wrap_around_count) </code></pre>
<p>由于可能的数据包丢失或重新排序，维护溢出计数 (wrap-around-count) 不是在序列号溢出为零时增加计数器的简单问题。 RTP 规范有一个维护溢出计数的算法：</p>
<pre><code>uint16_t    udelta = seq – max_seq 
if (udelta &lt; max_dropout) &#123;     
    if (seq &lt; max_seq) &#123;         
        wrap_around_count++ 
    &#125;     
    max_seq = seq; 
&#125;
else if (udelta &lt;= 65535 – max_misorder) &#123;
    // The sequence number made a very large jump     
    if (seq == bad_seq) &#123;
        // Two sequential packets received; assume the         
        // other side has restarted without telling us         
        ...     
    &#125; else &#123;
        bad_seq = seq + 1;
    &#125; 
&#125; 
else &#123;
    // Duplicate or misordered packet     
    ... 
&#125;</code></pre>
<p>请注意，所有计算都是使用模算术和 16 位无符号量完成的。 seq 和 max_seq 都是来自 RTP 数据包的未扩展序列号。 RTP 规范建议 max_misorder = 100 和 max_dropout = 3000</p>
<p>如果在接收到数据包时立即计算扩展序列号并在此后使用，则大多数应用程序可能忽略扩展序列号溢出。隐藏序列号溢出极大地简化了丢失检测和隐藏、数据包重新排序以及统计数据的维护。除非数据包速率非常高，否则 32 位序列号的溢出时间是大多数应用程序可以忽略的。例如，前面给出的 IP 语音示例将需要两年多的时间来溢出扩展序列号。</p>
<p>如果数据包速率非常高，则在应用程序运行时可能会出现 32 位扩展序列号溢出。在为此类环境设计应用程序时，必须使用更大的扩展序列号（例如 64 位）来避免该问题，或者通过使用 32 位模运算处理序列号溢出来构建应用程序.序列号溢出期间的不正确操作是一个常见问题，尤其是当数据包在溢出期间丢失或重新排序的时候。</p>
<p>序列号的初始值应该随机选择，而不是从零开始。此预防措施旨在使对加密 RTP 流的已知纯文本攻击更加困难。即使源不加密，使用随机初始序列号也很重要，因为流可能会通过源不知道的加密转换器，并且在转换器中添加随机偏移并非易事（因为序列号是在 RTCP 接收报告包中报告；参见 RTP 控制协议）。一个常见的实现问题是假设序列号从零开始；无论初始序列号如何，接收器都应该能够播放流（处理延迟连接也需要此功能）。</p>
<p>序列号应该始终遵循一个连续的序列，每发送一个数据包就增加一个，并且永远不会向前或向后跳跃（当然，环绕除外）。无论媒体如何生成，此要求都应适用于有效载荷格式的更改。例如，当您将视频剪辑拼接在一起时（可能是插入广告），RTP 序列号空间必须是连续的，并且不得在每个剪辑的开头重置。这对流媒体服务器的设计有影响，因为它们不能依赖与媒体文件一起存储的序列号，并且必须即时生成序列号。</p>
<p>序列号的主要用途是丢失检测。序列号空间中​​的间隙向接收器表明它必须采取行动来恢复或隐藏丢失的数据。这在 Error Concealment 和Error Correction 中有更详细的讨论。</p>
<p>序列号的第二个用途是允许重建数据包发送的顺序。接收器不一定关心这一点——因为许多有效载荷格式允许以任何顺序对数据包进行解码——但是在接收到数据包时将数据包按顺序排序可能会使丢失检测更容易。播出缓冲算法的设计在 Chapter 6 媒体捕捉、播出和计时中有更详细的讨论。</p>
<h3 id="2-1-3-TIMESTAMP（时间戳）"><a href="#2-1-3-TIMESTAMP（时间戳）" class="headerlink" title="2.1.3 TIMESTAMP（时间戳）"></a>2.1.3 TIMESTAMP（时间戳）</h3><p>RTP timestamp 表示数据包中媒体数据的第一个八位字节的采样时刻，用于调度媒体数据的播放。时间戳是一个 32 位无符号整数，它以与媒体相关的速率增加，并在超过最大值时环绕到零。对于典型的视频编解码器，使用 90kHz 的时钟频率，对应大约 13 小时的环绕；对于 8kHz 音频，间隔大约为 6 天。</p>
<p>时间戳的初始值是随机选择的，而不是从零开始。与序列号一样，此预防措施旨在使对加密 RTP 流的已知纯文本攻击更加困难。即使源不加密，随机初始时间戳的使用也很重要，因为流可能通过源不知道的加密转换器。一个常见的实现问题是假设时间戳从零开始。无论初始时间戳如何，接收器都应该能够播放流并准备好处理环绕；因为时间戳不是从零开始，所以任何时候都可能发生回绕。</p>
<p>时间戳回绕是 RTP 操作的正常部分，应由所有应用程序处理。使用扩展时间戳，可能是 64 位值，可以使大多数应用程序不知道回绕。但是，不建议使用扩展时间戳，因为 64 位算法在当今的处理器上通常效率低下。</p>
<p>更好的设计使用 32 位模运算执行所有时间戳计算。这种方法允许计算时间戳之间的差异，前提是比较的数据包在彼此的时间戳空间的一半之内。</p>
<p>时间戳源自必须以线性和单调方式增加的媒体时钟（当然，环绕式除外），为每个 RTP 会话生成单个时间线。这与生成媒体流的方式无关。</p>
<p>一个示例有助于阐明时间戳增加方式的含义：在单个 RTP 会话中将音频剪辑拼接在一起时，RTP 时间戳必须形成连续序列，并且不得在每个剪辑的开头重置。这些要求在 图 4.3 中进行了说明，这表明 RTP 接收器无法从 RTP 头中得知发生了变化。</p>
<p>当发生快进或倒带操作时也是如此：时间戳必须形成一个连续的序列，而不是跳来跳去。这一要求在实时流协议 (RTSP) 的设计中很明显，包括“正常播放时间”的概念，表示流中的时间索引。由于必须保持 RTP 时间戳的连续性，因此在查找操作期间，RTSP 服务器必须发送 RTP 时间戳与正常播放时间之间的更新映射。</p>
<p>RTP 时间戳的连续性对流媒体服务器的设计有影响。服务器不能依赖与媒体文件一起存储的时间戳（或序列号），但必须即时生成它们，同时考虑媒体中的查找操作和 RTP 会话中已播放的任何先前数据的持续时间。</p>
<p>对以线性和单调方式增加的媒体时钟的要求并不一定意味着媒体数据的采样顺序就是它的发送顺序。在生成媒体帧之后——因此获得了它们的时间戳——它们可以在分组之前重新排序。结果，即使保持序列号顺序，数据包也可能不按时间戳顺序传输。接收器必须重建时间戳顺序才能播放媒体。</p>
<p>一个例子是 MPEG 视频，它包含关键帧和从它们向前（P 帧）和向后（B 帧）预测的增量编码帧。当使用 B 帧时，它们是从后面的数据包中预测出来的，因此必须延迟并乱序发送。结果是 RTP 流将具有非单调递增的时间戳。 另一个例子是使用交错以减少突发丢失的影响。在所有情况下，接收者必须重建以播放媒体的单个时间线被保留。</p>
<p>RTP 数据包上的时间戳在每个环绕周期内不一定是唯一的。如果两个数据包包含来自同一采样时刻的数据，则它们将具有相同的时间戳。当一个大的视频帧被分成多个 RTP 数据包进行传输（数据包将具有不同的序列号但具有相同的时间戳）时，通常会发生时间戳的重复。</p>
<p>用于生成时间戳的媒体时钟的标称速率由使用的配置文件和/或有效载荷格式定义。对于具有静态有效载荷类型分配的有效载荷格式，当使用静态有效载荷类型时，时钟速率是隐式的（它被指定为有效载荷类型分配的一部分）。动态分配过程必须指定速率和有效载荷类型（参见本章前面标题为 Payload Type 的部分）。所选的速率必须足以以所需的精度执行唇形同步，并测量网络传输时间的变化。时钟频率不可任意选择；大多数有效载荷格式定义了一个或多个可接受的速率。</p>
<p>音频有效负载格式通常使用采样率作为其媒体时钟，因此每次读取完整样本时时钟增加 1。有两个例外： MPEG 音频使用 90kHz 时钟以兼容非 RTP MPEG 传输； G.722 是一种 16kHz 语音编解码器，它使用 8kHz 媒体时钟与 RFC 1890 向后兼容，RFC 1890 错误地指定了 8kHz 而不是 16kHz。</p>
<p>视频有效载荷格式通常使用 90kHz 时钟，以便与 MPEG 兼容，并且因为这样做会为当今广泛使用的典型 24Hz、25Hz、29.97Hz 和 30Hz 帧速率以及 50Hz、59.94Hz 和 60Hz 场速率产生整数时间戳增量.示例包括 PAL（相位交替线）和 NTSC（国家电视标准委员会）电视，以及 HDTV（高清晰度电视）格式。</p>
<p>重要的是要记住，RTP 不保证媒体时钟的分辨率、准确性或稳定性——这些属性被认为是依赖于应用程序的，并且超出了 RTP 的范围——一般来说，已知的只是其标称速率.应用程序应该能够在发送方和接收方处理媒体时钟的可变性，除非它们具有相反的特定知识。</p>
<hr>
<p><em>在某些情况下，可以定义媒体时钟的分辨率、精度和稳定性，并使用这些知识来简化应用程序设计。这通常只有在单个实体同时控制发送方和接收方，或者两者都设计为具有严格时钟规范的配置文件时才有可能</em></p>
<hr>
<h3 id="2-1-4-SSRC-SYNCHRONIZATION-SOURCE-（同步源）"><a href="#2-1-4-SSRC-SYNCHRONIZATION-SOURCE-（同步源）" class="headerlink" title="2.1.4 SSRC(SYNCHRONIZATION SOURCE)（同步源）"></a>2.1.4 SSRC(SYNCHRONIZATION SOURCE)（同步源）</h3><p>synchronization source (SSRC) 标识是 RTP 会话中的参与者。它是一个临时的、每个会话的标识符，通过 RTP 控制协议映射到一个长期存在的规范名称 CNAME。</p>
<p>SSRC 是一个 32 位整数，由参与者在加入会话时随机选择。选择一个 SSRC 标识符后，参与者在它发出的数据包中使用它。由于 SSRC 值是在本地选择的，因此两个参与者可以选择相同的值。当一个应用程序从另一个应用程序接收到包含为其自身选择的 SSRC 标识符的数据包时，可能会检测到此类冲突。</p>
<p>如果一个参与者检测到它正在使用的 SSRC 与另一个参与者选择的 SSRC 之间发生冲突，它必须为原始 SSRC 发送一个 RTCP BYE（参见标题为 RTCP BYE：Membership Control 的部分，在 Chapter 5，RTP 控制协议）并为自身选择另一个 SSRC。这种冲突检测机制确保 SSRC 对于会话中的每个参与者都是唯一的。</p>
<p>重要的是使用高质量的随机源来生成 SSRC，并实现碰撞检测。特别是，随机数生成器的种子不应基于会话加入的时间或会话的传输地址，因为如果多个参与者同时加入，可能会导致冲突。</p>
<p>具有相同 SSRC 的所有数据包构成单个时序和序列号空间的一部分，因此接收器必须按 SSRC 将数据包分组以进行回放。如果参与者在一个 RTP 会话中生成多个流——例如，来自不同的摄像机——每个流都必须被标识为不同的 SSRC，以便接收者可以区分哪些数据包属于每个流。</p>
<h3 id="2-1-5-CSRCs-CONTRIBUTING-SOURCE-（贡献源）"><a href="#2-1-5-CSRCs-CONTRIBUTING-SOURCE-（贡献源）" class="headerlink" title="2.1.5 CSRCs(CONTRIBUTING SOURCE)（贡献源）"></a>2.1.5 CSRCs(CONTRIBUTING SOURCE)（贡献源）</h3><p>在正常情况下，RTP 数据由单个源生成，但是当多个 RTP 流通过混合器或转换器时，多个数据源可能对一个 RTP 数据包做出了贡献。 contributing sources (CSRC) 的列表标识了对 RTP 数据包做出贡献但不负责其计时和同步的参与者。每个贡献源标识符是一个 32 位整数，对应于为此数据包做出贡献的参与者的 SSRC。 CSRC 列表的长度由 RTP 头中的 CC 字段指示。</p>
<p>包含 CSRC 列表的数据包是由 RTP 混合器的操作产生的，如本章后面标题为 mixers 的部分所述。当接收到包含CSRC列表的数据包时，SSRC按照通常的方式将数据包分组进行播出，并将每个CSRC添加到已知参与者列表中。由CSRC识别的每个参与者都会有相应的 RTP 控制协议数据包流，从而更全面地识别参与者。</p>
<h3 id="2-1-6-MARKER"><a href="#2-1-6-MARKER" class="headerlink" title="2.1.6 MARKER"></a>2.1.6 MARKER</h3><p>RTP 报头中的 marker (M) 位用于标记媒体流中感兴趣的事件；它的确切含义由使用的 RTP 配置文件和媒体类型定义。</p>
<p>对于在 RTP 配置文件下运行的音频和视频会议的最小控制的音频流，标记位设置为 1 以指示在一段时间的静音后发送的第一个数据包，否则设置为零。设置为 1 的标记位用作应用程序的提示，这可能是调整其播放点的好时机，因为静默期长度的微小变化通常不会被听众注意到（而播放中的变化正在播放音频时点是可听的）。</p>
<p>对于在 RTP 配置文件下运行的具有最小控制的音频和视频会议的视频流，标记位设置为 1 以指示视频帧的最后一个数据包，否则设置为 0。如果设置为 1，标记将用作应用程序可以开始解码帧的提示，而不是等待下一个数据包（将具有不同的时间戳）来检测应显示该帧。</p>
<p>在所有情况下，标记位仅向应用程序提供提示，即使设置了标记的数据包丢失，应用程序也应设计为操作。对于音频流，由于序列号和时间戳之间的关系发生变化，通常可以凭直觉判断静默期的结束。视频帧的开始可以通过时间戳的变化来检测。如果包含标记位的数据包丢失，应用程序可以使用这些观察来降低性能。</p>
<p>RTP 配置文件可以指定存在额外的标记位，代价是较小的有效载荷类型字段。例如，配置文件可以要求两个标记位和一个六位有效载荷类型。当前没有配置文件使用此功能。</p>
<h3 id="2-1-7-PADDING"><a href="#2-1-7-PADDING" class="headerlink" title="2.1.7 PADDING"></a>2.1.7 PADDING</h3><p>RTP 报头中的 padding (P) 位用于指示负载已被填充超过其自然长度。如果填充被添加到 RTP 数据包，则 P 位被设置，有效载荷的最后一个八位字节填充有填充八位字节数的计数。填充很少使用，但对于某些处理特定块大小的加密方案以及将有效载荷格式调整为固定容量信道，则需要使用填充。</p>
<p>作为使用填充的示例，图 4.4 显示了在 RTP 中打包的 GSM 音频帧，该帧已从 45 个八位字节的自然长度填充为 48 个八位字节（GSM 帧为 33，RTP 报头为 12）。如果使用数据加密标准 (DES)加密数据包，则可能需要此填充，该标准需要 8 个八位字节（64 位）块。</p>
<h3 id="2-1-8-VERSION-NUMBER"><a href="#2-1-8-VERSION-NUMBER" class="headerlink" title="2.1.8 VERSION NUMBER"></a>2.1.8 VERSION NUMBER</h3><p>每个 RTP 数据包包含一个 version number，由 V 字段指示。当前版本的 RTP 定义了附加版本，而以前的 RTP 版本并未广泛使用。版本号字段唯一有意义的用途是作为数据包有效性检查的一部分。</p>
<h2 id="2-2-Header-Extensions"><a href="#2-2-Header-Extensions" class="headerlink" title="2.2 Header Extensions"></a>2.2 Header Extensions</h2><p>RTP 允许扩展报头（由设置为 1 的 X 位表示）出现在固定 RTP 报头之后，在任何有效载荷报头和有效载荷本身之前。扩展头的长度可变，但它们以 16 位类型字段开始，后跟 16 位长度字段（以八位字节计算扩展的长度，不包括初始 32 位），允许不理解其的接收者忽略相关扩展。</p>
<p>扩展头为需要比固定 RTP 头提供的头信息更多的头信息的实验提供。它们很少使用；需要额外的、与有效载荷格式无关的头信息的扩展最好写成新的 RTP 配置文件。如果特定有效载荷格式需要额外的报头，则它们不应使用报头扩展，而应作为有效载荷报头携带在数据包的有效载荷部分中。</p>
<p>尽管标头扩展极为罕见，但应准备好通过忽略扩展来处理包含无法识别的标头扩展的数据包的健壮实现。</p>
<h2 id="2-3-Payload-Headers（负载头）"><a href="#2-3-Payload-Headers（负载头）" class="headerlink" title="2.3 Payload Headers（负载头）"></a>2.3 Payload Headers（负载头）</h2><p>强制 RTP 标头提供所有有效载荷格式通用的信息。在许多情况下，有效载荷格式需要更多信息才能实现最佳操作；此信息形成一个附加的标头，该标头被定义为有效载荷格式规范的一部分。有效载荷头包含在固定头和任何 CSRC 列表和头扩展之后的 RTP 数据包中。通常，有效载荷标头的定义构成了有效载荷格式规范的大部分。</p>
<p>负载标头中包含的信息可以是静态的（对于使用特定负载格式的每个会话都相同），也可以是动态的。有效载荷格式规范将指示有效载荷标头的哪些部分是静态的，哪些是动态的，并且必须在每个会话的基础上进行配置。那些动态的部分通常通过 SDP 配置，其中 <em>a=fmtp:</em> 属性用于定义“格式参数”，尽管有时会使用其他方式。可以指定的参数分为三类：</p>
<p>1.那些影响有效载荷标头格式的信号，表明标头字段的存在或不存在、它们的大小和它们的格式。例如，一些有效载荷格式有多种操作模式，可能需要不同的报头字段才能使用。</p>
<p>2.那些不影响payload头格式但定义了各种头域的使用。例如，一些有效载荷格式定义了交错的使用，并要求报头字段指示交错序列中的位置。 </p>
<p>3.那些影响有效载荷格式而不是有效载荷头的那些。例如，参数可以指定音频编解码器的帧大小或视频帧速率。</p>
<p>在会话期间不改变的有效载荷格式的特征通常为带库外信号的发送，而不是包含在有效载荷标头中。这减少了会话期间的开销，但代价是额外的信令复杂性。格式参数的语法和使用通常被指定为有效载荷格式规范的一部分。</p>
<p>指定有效载荷标头的主要原因是为那些不是设计用于有损数据包网络的格式提供错误恢复能力。第一个例子是 H.261 视频的有效载荷格式，如 RFC 2032 和 RFC 2736 中所讨论的最近的例子是 MP3 和 AMR（自适应多速率）音频的更容错的有效载荷格式. 在 Chapter 8, Error Concealment 和 9, Error Correction 中进一步讨论了错误恢复问题。</p>
<hr>
<p><em>H.261 视频的 RTP 有效载荷格式为错误恢复设计提供了一个有趣的教训。 H.261 编解码器允许视频块组最长为 3 KB。有效载荷格式的原始版本规定，每组块应直接插入到 RTP 数据包中，如果太大，则应在数据包之间任意拆分。然而，这种方法留下了数据包到达接收器并且必须丢弃的情况，因为前一个数据包丢失了，并且部分块组不能独立解码。这是我们想要避免的损失乘数效应。</em></p>
<p><em>实际上，块组并不是H.261视频中的最小单位。有一些更小的单元叫做 macro-blocks，但是如果不从块组的开头解析它们是无法识别的。然而，在每个数据包的开头包含附加信息可以恢复通常通过从块组的开头解析而找到的信息。此技术用于定义有效载荷格式，如果 H.261 流超过网络 MTU，则该格式将在宏块边界上拆分 H.261 流。</em></p>
<p><em>对于 H.261 而言，这是一种不太明显的打包方式，但它确实意味着智能解码器可以从丢失的 RTP 数据包流中重建有效的 H.261 视频，而不必丢弃任何到达的数据。它显示了有效载荷格式的容错设计的优点。</em></p>
<hr>
<h2 id="2-4-Payload-Data（负载数据）"><a href="#2-4-Payload-Data（负载数据）" class="headerlink" title="2.4 Payload Data（负载数据）"></a>2.4 Payload Data（负载数据）</h2><p>一帧或多帧媒体有效载荷数据，直接跟在任何有效载荷报头之后，构成 RTP 数据包的最后部分（除了填充，如果需要）。有效载荷数据的大小和格式取决于在会话设置期间选择的有效载荷格式和格式参数。</p>
<p>许多有效载荷格式允许在每个数据包中包含多个数据帧。接收器可以通过两种方式确定存在的帧数：</p>
<p>1.在许多情况下，帧的大小是固定的，可以通过检查数据包的大小来确定存在的数量。</p>
<p>2.其他有效载荷格式在每个封装的帧中包括一个标识符，指示帧的大小。应用程序需要解析封装的帧以确定帧数及其起始点。当框架可以是可变大小时，通常就是这种情况。</p>
<p>通常没有指定可能包含的帧数限制。接收器应处理接收各种大小的数据包：音频/视频配置文件中的指南建议音频的长度为 200 毫秒，是帧大小的倍数，视频编解码器应同时处理分段帧和完整帧。</p>
<p>当您选择要包含在每个数据包中的有效负载数据量时，需要考虑两个关键问题：将要经过的网络路径的最大传输单位 (MTU)，以及等待更多数据传输而引起的延迟生产以填充更长的包。</p>
<p>超过 MTU 的数据包将被分段或丢弃。如果过大的数据包被丢弃，这显然是不可取的；不那么明显的是由于碎片化造成的问题。如果所有碎片都到达，则碎片数据包将在接收器处重新组装。如果任何片段丢失，即使正确接收了整个数据包的某些部分，也必须丢弃整个数据包。结果是损失乘数效应，如果数据包的大小适当，并且有效载荷格式被设计为可以独立解码每个数据包（如与 有效载荷头 相关的讨论），则可以避免这种情况。</p>
<p>延迟是另一个问题，因为在生成它将包含的最后一个八位字节数据之前，无法发送数据包。数据包开始处的数据会延迟，直到完整的数据包准备就绪。在许多应用程序中，延迟问题对应用程序提供了比 MTU 更严格的约束。</p>
<h1 id="三、Packet-Validation（包验证）"><a href="#三、Packet-Validation（包验证）" class="headerlink" title="三、Packet Validation（包验证）"></a>三、Packet Validation（包验证）</h1><h1 id="四、Translators-and-Mixers"><a href="#四、Translators-and-Mixers" class="headerlink" title="四、Translators and Mixers"></a>四、Translators and Mixers</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/13/rtp2/" data-id="ckpwbg14m000568u6c8iyfkmo" data-title="rtp学习笔记（二） RTP数据传输协议" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rtp/" rel="tag">rtp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" rel="tag">音视频</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rtp1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/12/rtp1/" class="article-date">
  <time class="dt-published" datetime="2021-06-12T03:56:32.000Z" itemprop="datePublished">2021-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/12/rtp1/">rtp学习笔记（一） RTP传输协议介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>（来自《RTP：Audio and video for the Internet》第三章）</p>
<h1 id="RTP协议设计的基础原则"><a href="#RTP协议设计的基础原则" class="headerlink" title="RTP协议设计的基础原则"></a>RTP协议设计的基础原则</h1><h2 id="1-Application-Level-Framing-应用程序级别框架"><a href="#1-Application-Level-Framing-应用程序级别框架" class="headerlink" title="1.Application-Level Framing (应用程序级别框架)"></a>1.Application-Level Framing (应用程序级别框架)</h2><p>应用程序可以根据使用场景自动调整网络并从网络问题中恢复。同tcp设计的目标不同，tcp传输通过牺牲及时性保证可靠交互，而在实时音视频通信中则可以容忍损失的发生而保证其通信的实时性，并且通过一系列恢复技术恢复损失的帧数据。</p>
<p>这一原则可以暴露通用传输层的局限性，以便应用程序可以与网络合作以实现最佳可能的交付</p>
<h2 id="2-End-To-End-Principle-端对端原则"><a href="#2-End-To-End-Principle-端对端原则" class="headerlink" title="2.End-To-End Principle (端对端原则)"></a>2.End-To-End Principle (端对端原则)</h2><p>端点负责保证数据的可靠性，即使网络中丢失了数据，端点可完成对数据的恢复工作，其意味着网络设计可以相对简单无需保证传输鲁棒性。</p>
<h2 id="3-Achieving-Flexibility（实现灵活性）"><a href="#3-Achieving-Flexibility（实现灵活性）" class="headerlink" title="3.Achieving Flexibility（实现灵活性）"></a>3.Achieving Flexibility（实现灵活性）</h2><p>RTP 框架旨在满足许多场景，几乎没有额外的协议支持。在很大程度上，这种设计基于视频会议的轻量级会话模型。在这种情况下，RTP控制协议提供了所有必要的会话管理功能，加入会话所需的只是IP地址和来自媒体的映射RTP 负载类型标识符的定义。该模型也适用于一对多场景——例如，网络广播，其中控制协议提供的反馈提供了对观众规模和接收质量的估计的来源。</p>
<p>RTP 的优势在于它为实时音频/视频传输提供了一个统一的框架，直接满足大多数应用程序，但对于那些扩展其限制的应用程序具有可塑性。</p>
<h1 id="RTP协议标准元素"><a href="#RTP协议标准元素" class="headerlink" title="RTP协议标准元素"></a>RTP协议标准元素</h1><h2 id="1-RTP协议特性"><a href="#1-RTP协议特性" class="headerlink" title="1.RTP协议特性"></a>1.RTP协议特性</h2><p>RTP 通常位于 UDP/IP 传输之上，通过丢失检测和接收质量报告、定时恢复和同步、有效载荷和源识别以及媒体流中重要事件的标记来增强该传输。大多数RTP实现是位于操作系统提供的UDP/IP套接字接口之上的应用程序或库的一部分。然而，这并不是唯一可能的设计，而且 RTP 协议中没有任何内容需要UDP或IP。</p>
<p>RTP有两个部分：数据传输协议和相关的控制协议。</p>
<p>RTP数据传输协议管理实时数据（如音频和视频）在终端系统之间的传输。它为媒体有效载荷定义了额外的成帧级别，包括用于丢失检测的序列号、启用定时恢复的时间戳、有效载荷类型和源标识符，以及媒体流中重要事件的标记。还指定了时间戳和序列号使用规则，尽管这些规则在某种程度上取决于使用的配置文件和有效负载格式，以及用于在会话中多路复用多个流。</p>
<p>RTP 控制协议 (RTCP) 提供接收质量反馈、参与者识别和媒体流之间的同步。 RTCP 与 RTP 一起运行，并提供此信息的定期报告。尽管数据包通常每隔几毫秒发送一次，但控制协议以秒为单位运行。 RTCP 中发送的信息对于媒体流之间的同步（例如，音频和视频之间的口型同步）是必要的，并且对于根据接收质量反馈调整传输以及识别参与者非常有用。</p>
<p>RTP 支持 mixers和 translators 的概念，中间盒可以在媒体在端点之间流动时对其进行操作。这些可用于在不同的低层协议之间转换 RTP 会话，例如，在 IPv4 和 IPv6 网络上的参与者之间桥接，或将仅单播的参与者带入多播组。他们还可以以某种方式调整媒体流——例如，对数据格式进行转码以减少带宽，或将多个流混合在一起。</p>
<p>很难将 RTP 置于 OSI 参考模型中。它执行许多通常分配给传输层协议的任务，但它本身并不是一个完整的传输。 RTP 还执行会话层（跨越不同的传输连接并以传输中立的方式管理参与者标识）和表示层（定义媒体数据的标准表示）的一些任务</p>
<h3 id="2-RTP协议规范"><a href="#2-RTP协议规范" class="headerlink" title="2.RTP协议规范"></a>2.RTP协议规范</h3><p>了解 RTP 协议规范的限制很重要，因为它在两个方面故意不完整。首先，该标准没有规定媒体播放和定时再生、媒体流之间的同步、错误隐藏和纠正或拥塞控制的算法。这些是应用程序设计者的职责，因为不同的应用程序有不同的需求，标准强制要求单一行为是愚蠢的。当然，它确实为这些算法在指定后运行提供了必要的信息。后面的章节将讨论应用程序设计以及提供这些功能所固有的权衡</p>
<p>其次，传输的一些细节可以通过配置文件和有效载荷格式定义进行修改。</p>
<p>1.RTP 报头中的有效载荷类型标识符与有效载荷格式规范之间的映射（描述了如何将各个媒体编解码器与 RTP 一起使用）。每个配置文件将引用多种有效载荷格式，并可能指示如何使用特定的信令协议（例如 SDP）来描述映射。 </p>
<p>2.RTP 报头中有效载荷类型标识符字段的大小，以及用于标记媒体流中感兴趣的事件的位数。 </p>
<p>3.添加到固定的 RTP 数据传输协议标头，如果该标头证明对于特定类别的应用程序是不够的。</p>
<p>4.RTP 控制协议的报告间隔——例如，以额外开销为代价使反馈更及时。 </p>
<p>5.对要使用的 RTCP 数据包类型的限制，如果提供的某些信息对该类应用程序没有用处。此外，配置文件可以定义对 RTCP 的扩展以报告附加信息。</p>
<p>6.额外的安全机制——例如，新的加密和身份验证算法</p>
<p>7.RTP 和 RTCP 映射到低层传输协议。</p>
<h3 id="3-RTP承载格式"><a href="#3-RTP承载格式" class="headerlink" title="3.RTP承载格式"></a>3.RTP承载格式</h3><p>RTP 框架的最后一部分是负载格式，它定义了特定媒体类型在 RTP 中的传输方式。有效载荷格式由 RTP 配置文件引用，它们也可以定义 RTP 数据传输协议的某些属性。</p>
<p>RTP 负载格式和配置文件之间的关系主要是命名空间之一，尽管配置文件也可以指定负载格式的一些一般行为。命名空间将 RTP 数据包中的有效载荷类型标识符与有效载荷格式规范相关联，允许应用程序将数据与特定媒体编解码器相关联。在某些情况下，有效载荷类型和有效载荷格式之间的映射是静态的；在其他情况下，映射是通过带外控制协议动态进行的。例如，用于具有最小控制的音频和视频会议的 RTP 配置文件定义了一组静态有效载荷类型分配，以及用于标识有效载荷格式的 MIME 类型和使用会话描述协议 (SDP) 的有效载荷类型标识符之间的映射机制.</p>
<p>有效载荷格式和 RTP 数据传输协议之间的关系是双重的：有效载荷格式将指定某些 RTP 头字段的使用，并且它可以定义附加的有效载荷头。媒体编解码器产生的输出被转换成一系列 RTP 数据包——一些部分映射到 RTP 报头，一些映射到有效载荷报头，大部分映射到有效载荷数据。此映射过程的复杂性取决于编解码器的设计和所需的错误恢复程度。在某些情况下，映射很简单；在其他情况下，它更复杂。</p>
<p>简而言之，有效载荷格式仅定义媒体时钟和 RTP 时间戳之间的映射，并要求将编解码器输出的每一帧直接放入 RTP 数据包中进行传输。这方面的一个例子是 G.722.1 音频的有效载荷格式。不幸的是，这在很多情况下是不够的，因为许多编解码器是在没有参考数据包传输系统的需求的情况下开发的，需要适应这种环境。其他一些是为分组网络设计的，但需要额外的头信息。在这些情况下，有效载荷格式规范定义了一个附加的有效载荷头，放置在主 RTP 头之后，以及生成该头的规则。</p>
<p>已经定义了许多有效载荷格式，以匹配当今使用的编解码器的多样性，并且还有更多正在开发中。在撰写本文时，以下音频有效载荷格式是常用的，尽管这绝不是一个详尽的列表：G.711、G.723.1、G.726、G.728、G.729、GSM、QCELP , MP3, and DTMF. 常用的视频载荷格式包括H.261、H.263和MPEG</p>
<p>还有指定纠错方案的有效载荷格式。例如，RFC 2198 定义了音频冗余编码方案，和 RFC 2733 定义了基于奇偶校验编码的通用前向纠错方案。 在这些有效载荷格式中有一个额外的间接层，编解码器输出映射到 RTP 数据包，并且这些数据包本身被映射以产生一个容错传输。</p>
<h2 id="可选元素"><a href="#可选元素" class="headerlink" title="可选元素"></a>可选元素</h2><p>RTP 框架的两个可选部分在此阶段值得一提：标头压缩和多路复用。</p>
<p>报头压缩是一种可以在每个链路的基础上减少 RTP 和 UDP/IP 报头开销的方法。它用于带宽受限的链路——例如，蜂窝和拨号链路——并且可以将 RTP/UDP/IP 报头的 40 字节组合减少到 2 字节，代价是末端系统进行额外处理的压缩链接。</p>
<p>Multiplexing是将多个相关的 RTP 会话合并为一个的方法。再一次，动机是减少开销，除了这次程序是端到端运行的。</p>
<p>报头压缩和多路复用都可以被认为是 RTP 框架的一部分。与配置文件和有效载荷格式不同，它们显然是系统的特殊用途、可选部分，并且许多实现不使用这两种功能。</p>
<h1 id="相关标准"><a href="#相关标准" class="headerlink" title="相关标准"></a>相关标准</h1><p>除了 RTP 框架之外，一个完整的系统通常还需要使用各种其他协议和标准来满足呼叫建立和控制、会话描述、多方通信和信令服务质量要求。</p>
<h2 id="1-通话建立与控制"><a href="#1-通话建立与控制" class="headerlink" title="1.通话建立与控制"></a>1.通话建立与控制</h2><p>根据应用场景，可以使用各种呼叫建立、控制和广告协议来启动 RTP 会话：</p>
<p>1.1 为了启动交互式会话，无论是语音电话呼叫还是视频会议，有两种标准。该领域的原始标准是 ITU 推荐的 H.323，最近 IETF 定义了会话发起协议 (SIP)。<br>1.2 为了启动非交互式会话（例如视频点播），主要标准是实时流协议 (RTSP)<br>1.3 RTP 最初用于 IP 多播和会议的轻量级会话模型。此设计使用会话通告协议 (SAP) 和 IP 多播来通告对公众开放的正在进行的会话，例如研讨会和电视广播。</p>
<p>这些协议的要求非常不同，就会话的参与者数量和这些参与者之间的耦合而言。一些会话非常松散耦合，只有有限的成员控制和参与者的知识。其他人则受到严密管理，需要明确许可才能加入、交谈、聆听和观看。</p>
<p>这些不同的要求导致为每个场景设计了非常不同的协议，在该领域正在进行大量工作。 RTP 特意不包括会话启动和控制功能，使其适用于广泛的应用程序。</p>
<p>作为应用程序设计人员，除了 RTP 提供的媒体传输之外，您还必须实现某种形式的会话启动、呼叫建立或呼叫控制。</p>
<h2 id="2-会话描述"><a href="#2-会话描述" class="headerlink" title="2.会话描述"></a>2.会话描述</h2><p>所有设置和通知协议的共同点是需要一种描述会话的方法。该领域中一个常用的协议是会话描述协议 (SDP)，但也可以使用其他机制。</p>
<p>不管会话描述的格式如何，总是需要某些信息。必须传达媒体流的传输地址、媒体格式、要使用的 RTP 有效载荷格式和配置文件、会话处于活动状态的时间以及会话的目的。</p>
<p>SDP 将这些信息打包成文本文件格式，这种格式是人类可读的并且可以轻松解析。在某些情况下，此文件会直接传递给 RTP 应用程序，为其提供足够的信息以直接加入会话。在其他情况下，在参与者可以进入严格控制的电话会议之前，会话描述形成协商的基础，是呼叫建立协议的一部分。</p>
<h2 id="3-服务质量"><a href="#3-服务质量" class="headerlink" title="3.服务质量"></a>3.服务质量</h2><p>尽管 RTP 设计为在 IP 提供的尽力服务上运行，但有时能够保留网络资源是有用的，从而为 RTP 流提供更高的服务质量。再次声明，这不是RTP提供的服务，需要借助其他协议。在撰写本文时，Internet 上还没有普遍接受的资源预留“最佳实践”。存在两个标准框架，集成服务和差异化服务，每个框架的部署有限。</p>
<p>集成服务框架通过使用资源保留协议 (RSVP) 提供严格的服务质量保证。路由器需要将可用容量划分为服务类别，并考虑流量使用的容量。在开始传输之前，主机必须向路由器发出其要求的信号，只有在所需的服务等级中有足够的容量可用时，路由器才能成功。如果所有路由器都尊重服务等级并且不过度使用资源，则此要求可防止链路过载，从而提供有保证的服务质量。可用的服务类别包括有保证的服务（提供有保证的带宽水平、牢固的端到端延迟限制和无拥塞性数据包丢失）和受控负载（提供相当于轻负载尽力而为网络的服务） ）。</p>
<p>集成服务框架和 RSVP 需要为每个流进行预留，并且难以汇总这些预留。因此，将 RSVP 扩展到大量异构预留是有问题的，因为必须在路由器上保留大量状态，并且这种约束限制了其部署。</p>
<p>差异化服务框架对服务质量采取了一些不同的方法。它没有提供端到端的资源预留和严格的性能保证，而是定义了几种每跳排队行为，它通过设置每个数据包的 IP 标头中的服务类型字段来选择这些行为。这些每跳行为使路由器能够优先处理某些类型的流量，以降低丢失或延迟的可能性，但由于路由器无法控制进入网络的流量，因此不能绝对保证满足性能界限。差异化服务框架的优点是不需要复杂的信令，状态要求比 RSVP 小很多。缺点是它仅提供统计保证。</p>
<p>集成和差异化服务框架的结合是强大的，未来的网络可能会将它们结合起来。 RSVP 可用于向边缘路由器发送应用要求，然后这些路由器将这些要求映射到差异化服务流量类别上。这种组合允许边缘路由器拒绝过多的流量，提高差异化服务网络可以提供的保证，同时将 RSVP 所需的状态保持在网络核心之外。</p>
<p>这两个框架都有自己的位置，但在撰写本文时都没有达到临界质量。未来的网络可能会采用某种形式的服务质量，但绝不是肯定的。在此之前，我们的任务是使应用程序在当前部署的尽力而为网络中表现良好。</p>
<h1 id="未来协议发展"><a href="#未来协议发展" class="headerlink" title="未来协议发展"></a>未来协议发展</h1><p>随着 RTP 针对标准草案状态的修订，协议规范没有已知的未解决问题，并且在可预见的未来，RTP 本身预计不会发生变化。但这并不意味着标准工作已经完成。新的有效载荷格式一直在开发中，新配置文件的工作将扩展 RTP 以包含新功能（例如，用于安全 RTP 和增强反馈的配置文件）。</p>
<p>从长远来看，我们预计 RTP 框架会随着网络本身的发展而发展。网络未来的变化也可能影响 RTP，我们希望开发新的配置文件以利用任何变化。我们还期待一系列新的有效载荷格式规范，以跟上编解码器技术的变化并提供新的错误恢复方案。</p>
<p>最后，我们可以期待呼叫建立和控制、资源预留和服务质量的相关协议发生相当大的变化。这些协议比 RTP 更新，并且它们目前正在快速发展，这意味着这里的变化可能比 RTP、其配置文件和有效载荷格式的变化更大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/12/rtp1/" data-id="ckpwbg141000068u6afb02z65" data-title="rtp学习笔记（一） RTP传输协议介绍" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rtp/" rel="tag">rtp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" rel="tag">音视频</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/rtp/" rel="tag">rtp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" rel="tag">音视频</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/rtp/" style="font-size: 10px;">rtp</a> <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" style="font-size: 10px;">音视频</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/13/rtp2/">rtp学习笔记（二） RTP数据传输协议</a>
          </li>
        
          <li>
            <a href="/2021/06/12/rtp1/">rtp学习笔记（一） RTP传输协议介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 rionnag<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>